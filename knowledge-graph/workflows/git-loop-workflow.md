# Workflow: The Git-Loop

## Overview

The Git-Loop is the core workflow of the Sovereign Forge ecosystem. It ensures that all agent actions are auditable, reversible, and permanently recorded in the Git repository. This workflow implements the "Git-as-Memory" architecture, where the repository serves as the collective memory of the entire agent swarm.

## The Four Phases

### Phase 1: PULL (Context Acquisition)

Before taking any action, an agent must pull the latest context from the repository. This ensures the agent has the most up-to-date information.

**Actions:**
- Read the latest journal entries from `journal/`.
- Check the active story shards in `.agentic/manifests/active_story_shards.json`.
- Review the conductor manifest in `.agentic/manifests/conductor_manifest.json`.
- Read relevant knowledge graph articles from `knowledge-graph/`.
- Examine any artifacts or code files related to the current task.

**Why this matters:** Without pulling the latest context, an agent might work on outdated information, leading to conflicts or duplicated effort.

### Phase 2: PROCESS (Task Execution)

This is where the agent applies its domain expertise to execute the assigned task. The agent must follow the BMAD principles:

- **Spec-Driven:** Work from a validated spec (ArchitecturalSpec or StoryShardSpec).
- **Pydantic-Validated:** All data must conform to the defined schemas.
- **Security-Conscious:** Use SecretStr for sensitive data and follow security best practices.

**Actions:**
- Execute the primary task (generate code, create specs, run tests, etc.).
- Validate all outputs using Pydantic schemas.
- Create or modify artifacts (code files, documentation, configurations).
- Engage Sub-Agents if specialized tasks are needed.

**Why this matters:** This is where "The Sauce" is applied. Quality execution here determines the success of the entire project.

### Phase 3: JOURNAL (Internal Communication)

After completing the task, the agent must create a detailed journal entry that documents what was done, why it was done, and what the next steps are. This journal entry serves as communication to other agents and as a permanent record.

**Actions:**
- Create a new Markdown file in `journal/` with a timestamped filename.
- Include YAML front-matter with metadata (task_id, status, owner_agent, etc.).
- Write a detailed summary of the work performed.
- List all artifacts created or modified.
- List all Sub-Agents engaged (if any).
- Outline the next steps or blockers.

**Journal Entry Template:**

```markdown
---
task_id: "SHARD-XXX-DESCRIPTION"
status: "in_progress" | "completed" | "blocked"
owner_agent: "guru_agent_name"
contributing_agents: ["sub_agent_1", "sub_agent_2"]
last_sync: "2026-01-13T16:00:00Z"
security_clearance: 2
---

# Journal Entry: [Task Title]

**Date:** 2026-01-13  
**Agent:** [Agent Name]  
**Status:** [Status]

## Summary

[Detailed explanation of what was done and why]

## Sub-Agents Engaged

- [Sub-Agent 1]: [What they did]
- [Sub-Agent 2]: [What they did]

## Artifacts Created

- `path/to/file1.py`
- `path/to/file2.md`

## Next Steps

- [ ] Task 1
- [ ] Task 2

---

*Generated by [Agent Name]*
```

**Why this matters:** The journal is the primary communication mechanism between agents. Without it, agents would lose context and duplicate work.

### Phase 4: PUSH (Storage & Accessibility)

Finally, the agent commits all changes (artifacts and journal entry) to the Git repository and pushes them to the remote. This triggers GitHub Actions workflows that notify other agents and run automated checks.

**Actions:**
- Stage all created or modified files: `git add .`
- Commit with a descriptive message: `git commit -m "feat: description"`
- Push to the remote repository: `git push`

**Commit Message Format:**
```
<type>: <short description>

<optional detailed description>

<optional footer>
```

**Types:**
- `feat`: New feature or capability
- `fix`: Bug fix
- `docs`: Documentation changes
- `test`: Test additions or modifications
- `refactor`: Code refactoring
- `chore`: Maintenance tasks

**Why this matters:** Pushing to Git makes the work permanent and triggers automation. This is the final step that closes the loop.

## The Loop Never Stops

After pushing, the agent returns to Phase 1 (PULL) to check for new tasks or updates from other agents. This continuous loop ensures that all agents stay synchronized and work collaboratively.

## Error Handling

If an error occurs during any phase:

1. **Document the Error:** Create a journal entry describing the error and its context.
2. **Rollback if Necessary:** Use Git to revert to a known good state.
3. **Notify the Project Coordinator:** Report the error so it can be triaged and assigned.
4. **Learn from It:** Update the knowledge graph with lessons learned.

## Best Practices

- **Commit Often:** Small, frequent commits are better than large, infrequent ones.
- **Write Descriptive Messages:** Future agents (and humans) will thank you.
- **Never Skip the Journal:** Even if the task seems trivial, document it.
- **Pull Before You Push:** Always pull the latest changes before pushing to avoid conflicts.

## GitHub Actions Integration

When you push to the repository, the following workflows are triggered:

1. **Pydantic Validation:** Ensures all data conforms to schemas.
2. **Auto-Journaling:** Indexes the journal entry for searchability.
3. **Code Quality:** Runs linting and formatting checks.

These workflows provide immediate feedback and catch errors before they propagate.

---

*The Git-Loop is the heartbeat of the ecosystem. PULL → PROCESS → JOURNAL → PUSH. Repeat. Real recognize real.*
